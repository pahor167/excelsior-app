import { createAsyncThunk, createSlice, PayloadAction } from '@reduxjs/toolkit';
import { RootState, AppThunk, DI } from '../../app/store';
import { deployContractReal, fetchCount } from './wizardApi';
import { switchNetwork } from '@wagmi/core'
import { erc20 } from '@openzeppelin/wizard';

// import erc20Sol from "../../@openzeppelin/contracts/token/ERC20/ERC20.sol"
import {
  Solc,
  ImportCallbackFn,
  ImportCallbackReturnType,
} from "solc-browserify";

export interface Wizard {
  chainId: number;
  daoName: string;
  daoDescription: string;
  tokenName: string;
  tokenSymbol: string;

  // governorName: string;
  // votingDelayInBlocks: number;
  // votingPeriod: number;
  // proposalThreshold: number;
  // quorumPercent: number;


}

const initialState: Wizard = {
  chainId: 1,
  daoName: "",
  daoDescription: "",
  tokenName: "",
  tokenSymbol: "",
};

let erc20Contract = ""

// The function below is called a thunk and allows us to perform async logic. It
// can be dispatched like a regular action: `dispatch(incrementAsync(10))`. This
// will call the thunk with the `dispatch` function as the first argument. Async
// code can then be executed and other actions can be dispatched. Thunks are
// typically used to make async requests.
export const changeNetwork = createAsyncThunk(
  'wizard/changeNetwork',
  async (chainId: number, { getState, extra, dispatch}) => {
    const network = await switchNetwork({
      chainId: chainId,
    })
    dispatch(setChainId(network.id))
  }
);

const callback: ImportCallbackFn = function (
  path: string
): ImportCallbackReturnType {
  let contract: ImportCallbackReturnType;
  //   if (path.indexOf("@openzeppelin/contracts/token/ERC20/ERC20.sol") === 0) {
  //   contract = { contents: erc20Contract };
  // }


  contract = {
    error: `could not find source contract for ${path}`,
  };

  return contract;
};

export const generateAndBuild = createAsyncThunk(
  'wizard/generateAndBuild',
  async (chainId: number, { getState, extra, dispatch}) => {
    const contract = erc20.print();

  //   const res = await fetch(text)
  // const a = await res.text()

  // const res2 = await fetch(erc20Sol)
  // erc20Contract = await res2.text()
try {
  const compiler = new Solc(() => console.log("Initialized"));
    const output = await compiler.compile(contract, callback);
    console.log(output);
} catch (error) {
  console.log(error);
}

    
    // const versions = await getCompilerVersions() as any
    // const latestVersion = versions.latestRelease
    // const latestJsVersion = versions.releases[latestVersion]
    // console.log("versions", versions);
    // const res = await solidityCompiler({
    //   version: `https://binaries.soliditylang.org/bin/${latestJsVersion}`,
    //   contractBody: contract})
    // console.log("res", res);
    // const result = compileStandardWrapper(contract)
    // const network = await switchNetwork({
    //   chainId: chainId,
    // })
    // dispatch(setChainId(network.id))
  }
);

export const deployERC20 = createAsyncThunk(
  'wizard/deployERC20',
  async (dummy: string, { getState, extra}) => {
    const state = getState() as RootState
    await deployContractReal(state.wizard.tokenName, state.wizard.tokenSymbol)
  }
);

export const configDashboard = createSlice({
  name: 'counter',
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
    setChainId: (state, action: PayloadAction<number>) => {
      state.chainId = action.payload
    },
    setDaoName: (state, action: PayloadAction<string>) => {
      state.daoName = action.payload
    },
    setDaoDescription: (state, action: PayloadAction<string>) => {
      state.daoDescription = action.payload
    },
    setTokenName: (state, action: PayloadAction<string>) => {
      state.tokenName = action.payload
    },
    setTokenSymbol: (state, action: PayloadAction<string>) => {
      state.tokenSymbol = action.payload
    },
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {    
  },
});

export const { setChainId, setDaoName, setDaoDescription, setTokenName, setTokenSymbol } = configDashboard.actions;

export const selectChainId = (state: RootState) => state.wizard.chainId;
export const selectDaoName = (state: RootState) => state.wizard.daoName;
export const selectDaoDescription = (state: RootState) => state.wizard.daoDescription;
export const selectTokenName = (state: RootState) => state.wizard.tokenName;
export const selectTokenSymbol = (state: RootState) => state.wizard.tokenSymbol;

export default configDashboard.reducer;
